#! /usr/bin/env python
import json
import os
import pprint
import sys
import tarfile
import time
from pathlib import Path
from zipfile import ZipFile

import click
import filetype
import requests

# CONFIG
home = str(Path.home())
KELP_DIR = home + '/.kelp/'
DOWNLOAD_DIR = home + '/.kelp/packages/'  # needs the trailing slash


def load_config():
    try:
        with open(KELP_DIR + '.kelp.json', 'r') as file:
            packages = json.load(file)
            file.close()
            return packages
    except FileNotFoundError:
        print("Kelp config file not found")
        sys.exit(1)


def file_is_binary(filename):
    kind = filetype.guess(DOWNLOAD_DIR + filename)
    if kind is None:
        return False
    print('File extension: %s' % kind.extension)


def unzip_file(filename):
    print("unzipping {}".format(filename))
  # Create a ZipFile Object and load sample.zip in it
    with ZipFile(DOWNLOAD_DIR + filename, 'r') as zipObj:
        zipObj.extractall(path=DOWNLOAD_DIR)


def untar_file(filename):
    print("untarring {}".format(filename))
    with tarfile.open(DOWNLOAD_DIR + filename) as tar:
        tar.extractall(path=DOWNLOAD_DIR)


def download(download_url, filename):
    print("downloading {}".format(filename))
    response = requests.get(download_url)
    with open(DOWNLOAD_DIR + filename, 'wb') as f:
        f.write(response.content)


def install_packages(packages):
    for package in packages:
        owner, repo = package.split("/")
        release = packages[package]
        downloads = get_release_dl_url(owner, repo, release)
        if downloads:
            download_url = downloads['browser_download_url']
            filename = downloads['filename']
            download(download_url, filename)
            if filename.endswith(".zip"):
                unzip_file(filename)
            if filename.endswith(".gz"):
                untar_file(filename)
        time.sleep(2)


def get_release_dl_url(owner, repo, release):
    r = requests.get(
        'https://api.github.com/repos/{}/{}/releases/{}'.format(owner, repo, release))
    response = r.json()
    downloads = {}
    try:
        assets = response['assets']
        for asset in assets:
            mac_identifiers = ['mac', 'macOs', 'darwin']
            # TODO add .dmg support
            if any(word in asset['browser_download_url'] for word in mac_identifiers) and asset['browser_download_url'].endswith(('zip', '.gz')):
                downloads['browser_download_url'] = asset['browser_download_url']
                downloads['filename'] = asset['name']
                return downloads

    except KeyError:
        print("unable to download {}. Response was: {}".format(repo, response))
        return None


@click.command()
def init():
    os.mkdir(KELP_DIR)
    os.mkdir(DOWNLOAD_DIR)


@click.command()
def list():
    packages = load_config()
    pprint.pprint(packages)


@click.command()
def install():
    packages = load_config()
    install_packages(packages)


@click.command()
@click.argument('package')
@click.argument('release')
def add(package, release):
    packages = load_config()
    packages[package] = release

    with open(KELP_DIR + '.kelp.json', "w") as file:
        json.dump(packages, file, indent=4)


@click.command()
@click.argument('package')
def remove(package):
    packages = load_config()
    packages.pop(package)

    with open(KELP_DIR + '.kelp.json', "w") as file:
        json.dump(packages, file, indent=4)


@click.group()
def cli():
    pass


cli.add_command(list)
cli.add_command(install)
cli.add_command(init)
cli.add_command(add)
cli.add_command(remove)

if __name__ == "__main__":
    cli()
