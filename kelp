#! /usr/bin/env python
import json
import os
import pprint
import shutil
import sys
import tarfile
import tempfile
import time
from os import path, walk
from os.path import isfile, join
from pathlib import Path
from subprocess import call
from zipfile import ZipFile

import click
import filetype
import requests

# CONFIG
home = str(Path.home())
KELP_DIR = home + '/.kelp/'
CACHE_DIR = home + '/.kelp/cache/'  # needs the trailing slash
EXTRACT_DIR = home + '/.kelp/cache/extract/'  # dirpath = tempfile.mkdtemp()


def load_config():
    try:
        with open(KELP_DIR + '.kelp.json', 'r') as file:
            packages = json.load(file)
            file.close()
            return packages
    except FileNotFoundError:
        print("Kelp config file not found")
        sys.exit(1)


def file_is_binary(filepath):
    signatures = [
        "CF FA ED FE 07 00 00 01 03 00 00 80 02 00 00 00 14 00 00 00 C8 0F 00 00 85 00 00 00 00 00 00 00",
        "CF FA ED FE 07 00 00 01 03 00 00 00 02 00 00 00 0A 00 00 00 68 06 00 00 00 00 00 00 00 00 00 00",
        "CF FA ED FE 07 00 00 01 03 00 00 80 02 00 00 00 14 00 00 00 F8 08 00 00 85 00 A0 00 00 00 00 00",
        "CF FA ED FE 07 00 00 01 03 00 00 80 02 00 00 00 10 00 00 00 58 08 00 00 85 80 A1 00 00 00 00 00",
        "CF FA ED FE 07 00 00 01 03 00 00 80 02 00 00 00 14 00 00 00 D8 09 00 00 85 00 A0 00 00 00 00 00",
        "CF FA ED FE 07 00 00 01 03 00 00 80 02 00 00 00 12 00 00 00 38 08 00 00 85 00 A0 00 00 00 00 00",
        "50 4B 03 04 14 00 00 00 08 00 65 A5 B0 4E BD 97 36 55 97 84 C8 00 88 CF 7C 02 09 00 1C 00 74 65"
    ]
    try:
        file = open(filepath, "rb").read(32)
        hex_bytes = " ".join(['{:02X}'.format(byte) for byte in file])
        #print(f"{filepath}: {hex_bytes}")
        if hex_bytes in signatures:
            return True
        else:
            return False
    except IsADirectoryError:
        return False


def unzip_file(filepath):
    print(f"unzipping {filepath}")
    with ZipFile(filepath, 'r') as zipObj:
        zipObj.extractall(path=EXTRACT_DIR)


def untar_file(filepath):
    print(f"unzipping {filepath}")
    with tarfile.open(filepath) as tar:
        tar.extractall(path=EXTRACT_DIR)


def exists_in_cache(filepath):
    return path.exists(filepath)


def download(download_url, filename):
    print(f"downloading {filename}")
    response = requests.get(download_url)
    with open(CACHE_DIR + filename, 'wb') as f:
        f.write(response.content)


def extract_packages():
    for filename in os.listdir(CACHE_DIR):
        filepath = os.path.join(CACHE_DIR, filename)
        if filename.endswith(".zip"):
            unzip_file(filepath)
        if filename.endswith(".gz"):
            untar_file(filepath)
        if filename.endswith(".xz"):
            untar_file(filepath)
        if filename.endswith(".dmg"):
            shutil.copy2(filepath, KELP_DIR)
        if file_is_binary(filepath):
            shutil.copy2(filepath, KELP_DIR)


def move_binaries():
    for (dirpath, dirnames, filenames) in walk(EXTRACT_DIR):
        # copy .app files
        for dn in dirnames:
            if dn.endswith(".app"):
                filepath = os.path.join(dirpath, dn)
                call(['cp', '-r', filepath, KELP_DIR])
        # copy binary files
        for filename in filenames:
            filepath = os.path.join(dirpath, filename)
            if file_is_binary(filepath):
                shutil.copy2(filepath, KELP_DIR)


def install_packages(packages):
    for package in packages:
        release = packages[package]
        owner, repo = package.split("/")
        # support http projects
        if release.startswith("http"):
            filename = release.split("/")
            download(release, filename[-1])
        else:
            # support github projects
            release = get_release_dl_url(owner, repo, release)
            if release:
                download_url = release['browser_download_url']
                filename = release['filename']
                filepath = os.path.join(CACHE_DIR, filename)
                if exists_in_cache(filepath):
                    print(f"{filename} already exists in cache. skipping download")
                else:
                    download(download_url, filename)
        time.sleep(2)


def get_release_dl_url(owner, repo, release):
    api_token = os.getenv('GITHUB_TOKEN', None)
    if api_token:
        headers = {'Authorization': 'token %s' % api_token}
        r = requests.get(
            f'https://api.github.com/repos/{owner}/{repo}/releases/{release}', headers)
    else:
        r = requests.get(
            f'https://api.github.com/repos/{owner}/{repo}/releases/{release}')
    response = r.json()
    downloads = {}
    try:
        assets = response['assets']
        for asset in assets:
            # download mac binaries
            mac_identifiers = ['mac', 'macOs', 'darwin']
            if any(word in asset['browser_download_url'] for word in mac_identifiers):
                downloads['browser_download_url'] = asset['browser_download_url']
                downloads['filename'] = asset['name']
            # download dmg
            elif asset['browser_download_url'].endswith(".dmg"):
                downloads['browser_download_url'] = asset['browser_download_url']
                downloads['filename'] = asset['name']

        return downloads

    except KeyError:
        print(f"unable to download {repo}. Response was: {response}")
        return None


@click.command()
def init():
    os.mkdir(KELP_DIR)
    os.mkdir(CACHE_DIR)
    print(f"ðŸ—’ Add Kelp to your path by running \n export PATH=/Users/Craig/.local/bin:$PATH")


@click.command()
def list():
    packages = load_config()
    for package, release in packages.items():
        print(f"{package}:{release}")


@click.command()
def install():
    packages = load_config()
    install_packages(packages)
    extract_packages()
    move_binaries()
    print(f"âœ… Done!")


@click.command()
@click.argument('package')
@click.argument('release')
def add(package, release):
    # TODO add input validation
    # match = re.search("\d+\.\d+.\d+", "1.2.5")
    # print match.group()

    packages = load_config()
    packages[package] = release

    with open(KELP_DIR + '.kelp.json', "w") as file:
        json.dump(packages, file, indent=4)


@click.command()
@click.argument('package')
def remove(package):
    packages = load_config()
    packages.pop(package)

    with open(KELP_DIR + '.kelp.json', "w") as file:
        json.dump(packages, file, indent=4)


@click.command()
def inspect():
    call(['open', KELP_DIR])


@click.group()
def cli():
    pass


cli.add_command(list)
cli.add_command(install)
cli.add_command(init)
cli.add_command(add)
cli.add_command(remove)
cli.add_command(inspect)

if __name__ == "__main__":
    cli()
