#! /usr/bin/env python
import json
import os
import pprint
import re
import shutil
import sys
import tarfile
import tempfile
import time
from os import path, walk
from os.path import isfile, join
from pathlib import Path
from subprocess import call
from zipfile import ZipFile

import click
import filetype
import requests

# CONFIG
home = str(Path.home())
KELP_DIR = home + '/.kelp/'
KELP_BIN = home + '/.kelp/bin/'
CACHE_DIR = home + '/.kelp/cache/'  # needs the trailing slash
EXTRACT_DIR = tempfile.mkdtemp()


def load_config():
    try:
        with open(KELP_DIR + '.kelp.json', 'r') as file:
            packages = json.load(file)
            file.close()
            return packages
    except FileNotFoundError:
        print("Kelp config file not found")
        sys.exit(1)


def file_is_binary(filepath):
    signatures = [
        "CF FA ED FE",
        "50 4B 03 04",
        "1F 8B 08 00",
        "CF FA ED FE",
    ]
    try:
        file = open(filepath, "rb").read(32)
        hex_bytes = " ".join(['{:02X}'.format(byte) for byte in file])
        #print(f"{filepath}: {hex_bytes}")
        match = False
        for signature in signatures:
            if hex_bytes.startswith(signature) and not filepath.endswith((".dylib", ".tgz", ".gz", ".zip", ".pkg")):
                return True
        return False
    except IsADirectoryError:
        return False


def unzip_file(filepath):
    print(f"Unzipping {filepath}")
    with ZipFile(filepath, 'r') as zipObj:
        zipObj.extractall(path=EXTRACT_DIR)


def untar_file(filepath):
    print(f"Unzipping {filepath}")
    with tarfile.open(filepath) as tar:
        tar.extractall(path=EXTRACT_DIR)


def exists_in_cache(filepath):
    return path.exists(filepath)


def download(download_url, filename):
    print(f"Downloading {filename}")
    response = requests.get(download_url)
    with open(CACHE_DIR + filename, 'wb') as f:
        f.write(response.content)


def extract_packages():
    for filename in os.listdir(CACHE_DIR):
        filepath = os.path.join(CACHE_DIR, filename)
        if filename.endswith(".zip"):
            unzip_file(filepath)
        if filename.endswith(".gz"):
            untar_file(filepath)
        if filename.endswith(".xz"):
            untar_file(filepath)
        if filename.endswith(".dmg"):
            shutil.copy2(filepath, KELP_BIN)
        if file_is_binary(filepath):
            shutil.copy2(filepath, KELP_BIN)


def move_binaries():
    for (dirpath, dirnames, filenames) in walk(EXTRACT_DIR):
        # copy .app files
        for dn in dirnames:
            if dn.endswith(".app"):
                filepath = os.path.join(dirpath, dn)
                call(['cp', '-r', filepath, KELP_BIN])
        # copy binary files
        for filename in filenames:
            filepath = os.path.join(dirpath, filename)
            if file_is_binary(filepath):
                shutil.copy2(filepath, KELP_BIN)


def install_packages(packages):
    for package in packages:
        release = packages[package]
        owner, repo = package.split("/")
        # support http projects
        if release.startswith("http"):
            filename = release.split("/")
            download(release, filename[-1])
        else:
            # support github projects
            release = get_release_dl_url(owner, repo, release)
            if release:
                download_url = release['browser_download_url']
                filename = release['filename']
                filepath = os.path.join(CACHE_DIR, filename)
                if exists_in_cache(filepath):
                    print(f"{filename} already exists in cache.. Skipping download")
                else:
                    download(download_url, filename)
        time.sleep(2)


def get_release_dl_url(owner, repo, release):
    api_token = os.getenv('GITHUB_TOKEN', None)
    if api_token:
        headers = {'Authorization': 'token %s' % api_token}
        r = requests.get(
            f'https://api.github.com/repos/{owner}/{repo}/releases/{release}', headers)
    else:
        r = requests.get(
            f'https://api.github.com/repos/{owner}/{repo}/releases/{release}')
    response = r.json()
    downloads = {}
    try:
        assets = response['assets']
        for asset in assets:
            # download mac binaries
            mac_identifiers = ['mac', 'macOs', 'darwin']
            if any(word in asset['browser_download_url'] for word in mac_identifiers):
                downloads['browser_download_url'] = asset['browser_download_url']
                downloads['filename'] = asset['name']
            # download dmg or pkg
            elif asset['browser_download_url'].endswith((".dmg", ".pkg")):
                downloads['browser_download_url'] = asset['browser_download_url']
                downloads['filename'] = asset['name']

        return downloads

    except KeyError:
        print(f"Unable to download {repo}. Response was: {response}")
        return None


@click.command()
def init():
    if not os.path.isdir(KELP_DIR):
        os.mkdir(KELP_DIR)
    if not os.path.isdir(KELP_BIN):
        os.mkdir(KELP_BIN)
    if not os.path.isdir(CACHE_DIR):
        os.mkdir(CACHE_DIR)
    print(
        f"ðŸ—’ Add Kelp to your path by running \nexport PATH={KELP_BIN}:$PATH")


@click.command()
def list():
    packages = load_config()
    for package, release in packages.items():
        print(f"{package}:{release}")


@click.command()
def install():
    packages = load_config()
    install_packages(packages)
    extract_packages()
    move_binaries()
    print(f"âœ… Done!")


@click.command()
@click.argument('package')
@click.argument('release')
def add(package, release):

    match = re.search("\d+\.\d+.\d+", release)
    if not match:
        if not release.startswith("http"):
            if release != "latest":
                raise click.BadParameter(
                    'Invalid release name, it shouild either be latest, an http link or semvar format')

    if len(package.split("/")) != 2:
        raise click.BadParameter(
            'Invalid package name, it should follow username/repo format')

    packages = load_config()
    packages[package] = release

    with open(KELP_DIR + '.kelp.json', "w") as file:
        json.dump(packages, file, indent=4)


@click.command()
@click.argument('package')
def remove(package):
    packages = load_config()
    packages.pop(package)

    with open(KELP_DIR + '.kelp.json', "w") as file:
        json.dump(packages, file, indent=4)


@click.command()
def inspect():
    call(['open', KELP_DIR])


@click.group()
def cli():
    pass


cli.add_command(list)
cli.add_command(install)
cli.add_command(init)
cli.add_command(add)
cli.add_command(remove)
cli.add_command(inspect)

if __name__ == "__main__":
    cli()
